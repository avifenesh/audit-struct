# DWARF Technical Deep Dive

## Binary Analysis and Debug Information Parsing

---

## 1. Introduction to DWARF

**DWARF** (Debugging With Attributed Record Formats) is a hierarchical data format that describes the relationship between machine code in an executable and the source code that produced it.

### Why DWARF?

DWARF is the **ground truth** for struct layouts because:
- It's generated by the compiler
- It reflects actual memory layout after optimization
- It's standardized across compilers (GCC, Clang, MSVC*)
- It includes precise offset and size information

> *Note: MSVC uses PDB format, but `object` crate can handle conversion

---

## 2. DWARF Structure Overview

```
┌─────────────────────────────────────────────────────────────────┐
│                      DWARF Sections                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  .debug_info     Main debugging information (DIEs)              │
│  .debug_abbrev   Abbreviation tables (DIE templates)            │
│  .debug_str      String table (names, types)                    │
│  .debug_line     Line number information                        │
│  .debug_ranges   Address ranges                                 │
│  .debug_loc      Location lists                                 │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 2.1 Compilation Units (CUs)

DWARF is organized into **Compilation Units**, each roughly corresponding to a single source file:

```
Binary
├── CU: main.c
│   ├── DIE: function main()
│   ├── DIE: struct Order
│   └── DIE: variable config
├── CU: orders.c
│   ├── DIE: struct OrderBook
│   └── DIE: function process_order()
└── CU: utils.c
    └── ...
```

### 2.2 Debugging Information Entries (DIEs)

Each DIE has:
- **Tag**: What it represents (function, struct, variable)
- **Attributes**: Properties (name, size, location)

**Critical Tags for struct-audit**:

| Tag | Description |
|-----|-------------|
| `DW_TAG_structure_type` | C struct, C++ class, Rust struct |
| `DW_TAG_member` | Field within a struct |
| `DW_TAG_union_type` | Union type |
| `DW_TAG_inheritance` | C++ base class |
| `DW_TAG_base_type` | Primitive types (int, float) |
| `DW_TAG_pointer_type` | Pointer to another type |
| `DW_TAG_array_type` | Array type |

---

## 3. Attribute Resolution

### 3.1 Name Resolution

The `DW_AT_name` attribute is often an offset into `.debug_str`:

```rust
// Pseudo-code for name resolution
fn resolve_name(die: &DIE, dwarf: &Dwarf) -> Option<String> {
    match die.attr(DW_AT_name)? {
        AttributeValue::String(s) => Some(s.to_string()),
        AttributeValue::DebugStrRef(offset) => {
            dwarf.debug_str.get_str(offset).ok()
        }
        _ => None
    }
}
```

### 3.2 Size Resolution

`DW_AT_byte_size` gives the total size of a struct:

```rust
fn get_struct_size(die: &DIE) -> Option<u64> {
    die.attr(DW_AT_byte_size)?
       .udata_value()
}
```

### 3.3 Member Location (The Complex Part)

`DW_AT_data_member_location` can be:

1. **Simple constant**: Direct byte offset
2. **Location expression**: Stack-based bytecode program

```rust
fn get_member_offset(die: &DIE, dwarf: &Dwarf) -> Result<u64> {
    let attr = die.attr(DW_AT_data_member_location)?;
    
    match attr.value() {
        // Simple case: constant offset
        AttributeValue::Udata(offset) => Ok(offset),
        AttributeValue::Sdata(offset) => Ok(offset as u64),
        
        // Complex case: location expression
        AttributeValue::Exprloc(expr) => {
            evaluate_location_expr(expr, dwarf)
        }
        
        _ => Err(Error::UnsupportedLocationFormat)
    }
}
```

---

## 4. Location Expression Evaluation

For complex C++ layouts (virtual inheritance), DWARF uses a stack-based bytecode:

### 4.1 Common Operations

| Opcode | Description |
|--------|-------------|
| `DW_OP_plus_uconst` | Add unsigned constant to stack top |
| `DW_OP_constu` | Push unsigned constant |
| `DW_OP_deref` | Dereference pointer (runtime only) |
| `DW_OP_addr` | Push address |

### 4.2 Evaluation Example

```
Expression: DW_OP_constu 8, DW_OP_plus

Stack trace:
  [empty]
  → DW_OP_constu 8  → [8]
  → DW_OP_plus      → [base_addr + 8]
  
Result: offset = 8
```

### 4.3 Implementation with gimli

```rust
use gimli::{Evaluation, EvaluationResult};

fn evaluate_location_expr(
    expr: Expression<R>,
    encoding: Encoding,
) -> Result<u64> {
    let mut eval = expr.evaluation(encoding);
    eval.set_initial_value(0); // Base address = 0 for offset calc
    
    loop {
        match eval.evaluate()? {
            EvaluationResult::Complete => break,
            EvaluationResult::RequiresMemory { .. } => {
                // For struct-audit, we don't need runtime memory
                return Err(Error::RuntimeLocationNotSupported);
            }
            EvaluationResult::RequiresRegister { .. } => {
                return Err(Error::RuntimeLocationNotSupported);
            }
            // Handle other cases...
        }
    }
    
    let result = eval.result();
    // Extract offset from result
    Ok(result[0].location.unwrap_or(0))
}
```

---

## 5. The Bitfield Challenge: DWARF 4 vs DWARF 5

### 5.1 The Problem

Bitfields require special handling because their representation changed between DWARF versions.

**Example struct**:
```c
struct Flags {
    uint32_t active:1;
    uint32_t priority:3;
    uint32_t reserved:28;
};
```

### 5.2 DWARF 4 (and earlier)

Uses `DW_AT_bit_offset` and `DW_AT_bit_size`:

```
DW_AT_bit_offset: Bits from START of storage unit (big-endian)
                  OR from END of storage unit (little-endian)
```

**The "Big-Endian Bias"**: On x86 (little-endian), calculations are counter-intuitive.

```rust
// DWARF 4 bitfield offset calculation (little-endian)
fn dwarf4_bit_offset(
    bit_offset: u64,      // DW_AT_bit_offset
    bit_size: u64,        // DW_AT_bit_size
    storage_size: u64,    // Size of containing storage unit in bytes
) -> u64 {
    let storage_bits = storage_size * 8;
    // Offset from end of storage unit
    storage_bits - bit_offset - bit_size
}
```

### 5.3 DWARF 5

Introduces `DW_AT_data_bit_offset`:

```
DW_AT_data_bit_offset: Bits from START of containing entity
                       (endianness-independent)
```

Much simpler:
```rust
// DWARF 5 bitfield offset calculation
fn dwarf5_bit_offset(data_bit_offset: u64) -> u64 {
    data_bit_offset // Direct offset from struct start
}
```

### 5.4 Version Detection

```rust
fn get_bitfield_offset(
    die: &DIE,
    cu: &CompilationUnit,
) -> Result<BitfieldLocation> {
    let dwarf_version = cu.header.version();
    
    if dwarf_version >= 5 {
        // DWARF 5: Use DW_AT_data_bit_offset
        if let Some(offset) = die.attr(DW_AT_data_bit_offset) {
            return Ok(BitfieldLocation {
                bit_offset: offset.udata_value().unwrap(),
                bit_size: get_bit_size(die)?,
            });
        }
    }
    
    // DWARF 4 or fallback: Use DW_AT_bit_offset
    let bit_offset = die.attr(DW_AT_bit_offset)
        .and_then(|a| a.udata_value())
        .ok_or(Error::MissingBitOffset)?;
    
    let bit_size = get_bit_size(die)?;
    let storage_size = get_storage_unit_size(die)?;
    
    // Convert to absolute bit offset
    let absolute_offset = dwarf4_bit_offset(
        bit_offset, 
        bit_size, 
        storage_size
    );
    
    Ok(BitfieldLocation {
        bit_offset: absolute_offset,
        bit_size,
    })
}
```

---

## 6. Type Chain Resolution

Types in DWARF form a chain that must be followed to get the final type:

```
struct Order {
    OrderId id;  // typedef → struct → ...
}

DIE Chain:
DW_TAG_member "id"
  └── DW_AT_type → DW_TAG_typedef "OrderId"
                     └── DW_AT_type → DW_TAG_structure_type
                                        └── DW_AT_byte_size = 16
```

### Implementation

```rust
fn resolve_type_size(
    type_offset: UnitOffset,
    unit: &Unit,
    dwarf: &Dwarf,
) -> Result<u64> {
    let mut current = type_offset;
    
    loop {
        let die = unit.entry(current)?;
        
        // Check if this DIE has a size
        if let Some(size) = die.attr(DW_AT_byte_size) {
            return Ok(size.udata_value().unwrap());
        }
        
        // Follow the type chain
        match die.attr(DW_AT_type) {
            Some(attr) => {
                current = match attr.value() {
                    AttributeValue::UnitRef(offset) => offset,
                    _ => return Err(Error::InvalidTypeRef),
                };
            }
            None => {
                // Reached end of chain without finding size
                // This might be a void type or error
                return Err(Error::TypeSizeNotFound);
            }
        }
    }
}
```

---

## 7. gimli Integration

### 7.1 Why gimli?

| Feature | gimli | libdwarf |
|---------|-------|----------|
| Language | Rust | C |
| Memory Safety | ✅ Guaranteed | ❌ Manual |
| Zero-Copy | ✅ Yes | ❌ No |
| Lazy Evaluation | ✅ Yes | ❌ No |
| Large Binary Support | ✅ Efficient | ⚠️ Memory issues |

### 7.2 Basic Setup

```rust
use gimli::{Dwarf, EndianSlice, LittleEndian, RunTimeEndian};
use object::{Object, ObjectSection};

fn load_dwarf(binary_path: &Path) -> Result<Dwarf<EndianSlice<RunTimeEndian>>> {
    let file = std::fs::read(binary_path)?;
    let object = object::File::parse(&*file)?;
    
    // Determine endianness
    let endian = if object.is_little_endian() {
        RunTimeEndian::Little
    } else {
        RunTimeEndian::Big
    };
    
    // Load DWARF sections
    let load_section = |id: gimli::SectionId| -> Result<_> {
        let data = object
            .section_by_name(id.name())
            .map(|s| s.data().unwrap_or(&[]))
            .unwrap_or(&[]);
        Ok(EndianSlice::new(data, endian))
    };
    
    let dwarf = Dwarf::load(&load_section)?;
    Ok(dwarf)
}
```

### 7.3 Iterating Structs

```rust
fn find_structs(dwarf: &Dwarf<R>) -> Result<Vec<StructLayout>> {
    let mut structs = Vec::new();
    
    // Iterate compilation units
    let mut units = dwarf.units();
    while let Some(header) = units.next()? {
        let unit = dwarf.unit(header)?;
        
        // Iterate DIEs in this unit
        let mut entries = unit.entries();
        while let Some((_, entry)) = entries.next_dfs()? {
            if entry.tag() == DW_TAG_structure_type {
                if let Some(layout) = parse_struct(entry, &unit, dwarf)? {
                    structs.push(layout);
                }
            }
        }
    }
    
    Ok(structs)
}
```

---

## 8. Edge Cases and Challenges

### 8.1 Anonymous Structs

```c
struct Outer {
    struct {  // Anonymous inner struct
        int x, y;
    } point;
};
```

**Handling**: Generate synthetic names like `Outer::__anon_0`

### 8.2 Packed Structs

```rust
#[repr(packed)]
struct Packed {
    a: u8,
    b: u64,  // No padding!
}
```

**Detection**: `DW_AT_byte_size` won't match expected aligned size

### 8.3 Zero-Sized Types (Rust)

```rust
struct ZST;  // Size = 0
```

**Handling**: Report but don't flag as problematic

### 8.4 Incomplete Types

Forward declarations without definition:
```c
struct Forward;  // No DW_AT_byte_size
```

**Handling**: Skip or mark as "incomplete"

---

## 9. Performance Optimizations

### 9.1 Lazy Parsing

Only parse what's needed:
```rust
// Skip function bodies entirely
if entry.tag() == DW_TAG_subprogram {
    entries.skip_children()?;
    continue;
}
```

### 9.2 Parallel Processing

Process compilation units in parallel:
```rust
use rayon::prelude::*;

let structs: Vec<_> = unit_headers
    .par_iter()
    .flat_map(|header| {
        find_structs_in_unit(header, &dwarf)
    })
    .collect();
```

### 9.3 Caching Type Resolution

```rust
use std::collections::HashMap;

struct TypeCache {
    sizes: HashMap<UnitOffset, u64>,
}

impl TypeCache {
    fn get_or_resolve(&mut self, offset: UnitOffset, ...) -> u64 {
        if let Some(&size) = self.sizes.get(&offset) {
            return size;
        }
        let size = resolve_type_size(offset, ...);
        self.sizes.insert(offset, size);
        size
    }
}
```

---

## Next Steps

→ [Algorithms](./06-algorithms.md) - Padding detection and cache analysis algorithms


